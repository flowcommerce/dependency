/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.2.10
 * apibuilder 0.14.75 app.apibuilder.io/flow/github/0.2.10/play_2_6_client
 */
package io.flow.github.v0.models {

  final case class Blob(
    content: String,
    encoding: io.flow.github.v0.models.Encoding,
    url: String,
    sha: String,
    size: Long
  )

  final case class BlobCreated(
    url: String,
    sha: String
  )

  final case class BlobForm(
    content: String,
    encoding: io.flow.github.v0.models.Encoding = io.flow.github.v0.models.Encoding.Utf8
  )

  final case class Commit(
    sha: String,
    url: String,
    htmlUrl: String,
    author: io.flow.github.v0.models.Person,
    committer: io.flow.github.v0.models.Person,
    tree: io.flow.github.v0.models.TreeSummary,
    message: String,
    parents: Seq[io.flow.github.v0.models.CommitSummary]
  )

  final case class CommitForm(
    message: String,
    tree: String,
    parents: Seq[String],
    author: io.flow.github.v0.models.Person,
    committer: io.flow.github.v0.models.Person
  )

  final case class CommitResponse(
    sha: String,
    url: String,
    author: io.flow.github.v0.models.Person,
    committer: io.flow.github.v0.models.Person,
    message: String,
    tree: io.flow.github.v0.models.TreeSummary,
    parents: Seq[io.flow.github.v0.models.TreeSummary]
  )

  final case class CommitSummary(
    sha: String,
    url: String
  )

  /**
   * @param content If file, then present
   */
  final case class Contents(
    `type`: io.flow.github.v0.models.ContentsType,
    encoding: io.flow.github.v0.models.Encoding,
    size: Long,
    name: String,
    path: String,
    content: _root_.scala.Option[String] = None,
    sha: String,
    url: String,
    gitUrl: String,
    htmlUrl: String,
    downloadUrl: String
  )

  final case class CreateTreeForm(
    baseTree: String,
    tree: Seq[io.flow.github.v0.models.TreeForm]
  )

  final case class CreateTreeResponse(
    sha: String,
    url: String,
    treeResult: io.flow.github.v0.models.Tree
  )

  final case class Error(
    resource: String,
    field: String,
    code: String
  )

  final case class GithubObject(
    `type`: String,
    sha: String,
    url: String
  )

  /**
   * See https://developer.github.com/v3/repos/hooks/#create-a-hook
   */
  final case class Hook(
    id: Long,
    url: String,
    testUrl: String,
    pingUrl: String,
    name: String,
    events: Seq[io.flow.github.v0.models.HookEvent],
    active: Boolean,
    config: io.flow.github.v0.models.HookConfig,
    updatedAt: _root_.org.joda.time.DateTime,
    createdAt: _root_.org.joda.time.DateTime
  )

  final case class HookConfig(
    url: _root_.scala.Option[String] = None,
    contentType: _root_.scala.Option[String] = None
  )

  final case class HookForm(
    name: String,
    config: io.flow.github.v0.models.HookConfig,
    events: Seq[io.flow.github.v0.models.HookEvent],
    active: Boolean
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */
  final case class Node(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    size: Long,
    sha: String,
    url: String
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */
  final case class NodeForm(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    sha: String
  )

  final case class Person(
    name: String,
    email: String,
    date: _root_.org.joda.time.DateTime
  )

  final case class PullRequest(
    id: Long,
    url: String,
    number: Long,
    htmlUrl: String,
    head: io.flow.github.v0.models.PullRequestHead
  )

  final case class PullRequestForm(
    title: String,
    head: String,
    base: String,
    body: _root_.scala.Option[String] = None
  )

  final case class PullRequestHead(
    ref: String
  )

  final case class Ref(
    ref: String,
    url: String,
    `object`: io.flow.github.v0.models.GithubObject
  )

  final case class RefForm(
    ref: String,
    sha: String
  )

  final case class RefUpdateForm(
    sha: String
  )

  final case class Repository(
    id: Long,
    owner: io.flow.github.v0.models.User,
    name: String,
    fullName: String,
    `private`: Boolean,
    description: _root_.scala.Option[String] = None,
    url: String,
    htmlUrl: String
  )

  final case class Tag(
    tag: String,
    sha: String,
    url: String,
    message: String,
    tagger: io.flow.github.v0.models.Tagger,
    `object`: io.flow.github.v0.models.GithubObject
  )

  /**
   * @param `object` The SHA of the git object this is tagging
   */
  final case class TagForm(
    tag: String,
    message: String,
    `object`: String,
    `type`: String = "commit",
    tagger: io.flow.github.v0.models.Tagger
  )

  final case class TagSummary(
    name: String,
    commit: io.flow.github.v0.models.CommitSummary
  )

  final case class Tagger(
    name: String,
    email: String,
    date: _root_.org.joda.time.DateTime
  )

  final case class Tree(
    sha: String,
    url: String,
    truncated: Boolean,
    tree: Seq[io.flow.github.v0.models.Node]
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */
  final case class TreeForm(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    sha: _root_.scala.Option[String] = None,
    content: _root_.scala.Option[String] = None
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */
  final case class TreeResult(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    size: Long,
    sha: String,
    url: String
  )

  final case class TreeSummary(
    url: String,
    sha: String
  )

  final case class UnprocessableEntity(
    message: String,
    errors: _root_.scala.Option[Seq[io.flow.github.v0.models.Error]] = None
  )

  final case class User(
    id: Long,
    login: String,
    name: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None,
    avatarUrl: _root_.scala.Option[String] = None,
    gravatarId: _root_.scala.Option[String] = None,
    url: String,
    htmlUrl: String,
    `type`: io.flow.github.v0.models.OwnerType
  )

  final case class UserEmail(
    email: String,
    verified: Boolean,
    primary: Boolean
  )

  sealed trait ContentsType extends _root_.scala.Product with _root_.scala.Serializable

  object ContentsType {

    case object File extends ContentsType { override def toString = "file" }
    case object Dir extends ContentsType { override def toString = "dir" }
    case object Symlink extends ContentsType { override def toString = "symlink" }
    case object Submodule extends ContentsType { override def toString = "submodule" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ContentsType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ContentsType] = scala.List(File, Dir, Symlink, Submodule)

    private[this]
    val byName: Map[String, ContentsType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ContentsType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ContentsType] = byName.get(value.toLowerCase)

  }

  sealed trait Encoding extends _root_.scala.Product with _root_.scala.Serializable

  object Encoding {

    case object Base64 extends Encoding { override def toString = "base64" }
    case object Utf8 extends Encoding { override def toString = "utf-8" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Encoding

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Encoding] = scala.List(Base64, Utf8)

    private[this]
    val byName: Map[String, Encoding] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Encoding = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Encoding] = byName.get(value.toLowerCase)

  }

  sealed trait HookEvent extends _root_.scala.Product with _root_.scala.Serializable

  object HookEvent {

    case object Push extends HookEvent { override def toString = "push" }
    case object PullRequest extends HookEvent { override def toString = "pull_request" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends HookEvent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[HookEvent] = scala.List(Push, PullRequest)

    private[this]
    val byName: Map[String, HookEvent] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): HookEvent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[HookEvent] = byName.get(value.toLowerCase)

  }

  sealed trait NodeType extends _root_.scala.Product with _root_.scala.Serializable

  object NodeType {

    case object Blob extends NodeType { override def toString = "blob" }
    case object Tree extends NodeType { override def toString = "tree" }
    case object Commit extends NodeType { override def toString = "commit" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends NodeType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[NodeType] = scala.List(Blob, Tree, Commit)

    private[this]
    val byName: Map[String, NodeType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): NodeType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[NodeType] = byName.get(value.toLowerCase)

  }

  sealed trait OwnerType extends _root_.scala.Product with _root_.scala.Serializable

  object OwnerType {

    case object User extends OwnerType { override def toString = "User" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OwnerType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OwnerType] = scala.List(User)

    private[this]
    val byName: Map[String, OwnerType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OwnerType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OwnerType] = byName.get(value.toLowerCase)

  }

  sealed trait Visibility extends _root_.scala.Product with _root_.scala.Serializable

  object Visibility {

    case object All extends Visibility { override def toString = "all" }
    case object Public extends Visibility { override def toString = "public" }
    case object Private extends Visibility { override def toString = "private" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Visibility

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Visibility] = scala.List(All, Public, Private)

    private[this]
    val byName: Map[String, Visibility] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Visibility = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Visibility] = byName.get(value.toLowerCase)

  }

}

package io.flow.github.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.github.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map { str =>
      _root_.java.util.UUID.fromString(str)
    }

    private[v0] implicit val jsonWritesUUID = new Writes[_root_.java.util.UUID] {
      def writes(x: _root_.java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[_root_.org.joda.time.DateTime] {
      def writes(x: _root_.org.joda.time.DateTime) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x))
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[_root_.org.joda.time.LocalDate] {
      def writes(x: _root_.org.joda.time.LocalDate) = {
        JsString(_root_.org.joda.time.format.ISODateTimeFormat.date.print(x))
      }
    }

    implicit val jsonReadsGithubContentsType = new play.api.libs.json.Reads[io.flow.github.v0.models.ContentsType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.github.v0.models.ContentsType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.github.v0.models.ContentsType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.github.v0.models.ContentsType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesGithubContentsType(obj: io.flow.github.v0.models.ContentsType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectContentsType(obj: io.flow.github.v0.models.ContentsType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesGithubContentsType: play.api.libs.json.Writes[ContentsType] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.ContentsType] {
        def writes(obj: io.flow.github.v0.models.ContentsType) = {
          jsonWritesGithubContentsType(obj)
        }
      }
    }

    implicit val jsonReadsGithubEncoding = new play.api.libs.json.Reads[io.flow.github.v0.models.Encoding] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.github.v0.models.Encoding] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.github.v0.models.Encoding(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.github.v0.models.Encoding(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesGithubEncoding(obj: io.flow.github.v0.models.Encoding) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectEncoding(obj: io.flow.github.v0.models.Encoding) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesGithubEncoding: play.api.libs.json.Writes[Encoding] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Encoding] {
        def writes(obj: io.flow.github.v0.models.Encoding) = {
          jsonWritesGithubEncoding(obj)
        }
      }
    }

    implicit val jsonReadsGithubHookEvent = new play.api.libs.json.Reads[io.flow.github.v0.models.HookEvent] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.github.v0.models.HookEvent] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.github.v0.models.HookEvent(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.github.v0.models.HookEvent(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesGithubHookEvent(obj: io.flow.github.v0.models.HookEvent) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectHookEvent(obj: io.flow.github.v0.models.HookEvent) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesGithubHookEvent: play.api.libs.json.Writes[HookEvent] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.HookEvent] {
        def writes(obj: io.flow.github.v0.models.HookEvent) = {
          jsonWritesGithubHookEvent(obj)
        }
      }
    }

    implicit val jsonReadsGithubNodeType = new play.api.libs.json.Reads[io.flow.github.v0.models.NodeType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.github.v0.models.NodeType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.github.v0.models.NodeType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.github.v0.models.NodeType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesGithubNodeType(obj: io.flow.github.v0.models.NodeType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectNodeType(obj: io.flow.github.v0.models.NodeType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesGithubNodeType: play.api.libs.json.Writes[NodeType] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.NodeType] {
        def writes(obj: io.flow.github.v0.models.NodeType) = {
          jsonWritesGithubNodeType(obj)
        }
      }
    }

    implicit val jsonReadsGithubOwnerType = new play.api.libs.json.Reads[io.flow.github.v0.models.OwnerType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.github.v0.models.OwnerType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.github.v0.models.OwnerType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.github.v0.models.OwnerType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesGithubOwnerType(obj: io.flow.github.v0.models.OwnerType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectOwnerType(obj: io.flow.github.v0.models.OwnerType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesGithubOwnerType: play.api.libs.json.Writes[OwnerType] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.OwnerType] {
        def writes(obj: io.flow.github.v0.models.OwnerType) = {
          jsonWritesGithubOwnerType(obj)
        }
      }
    }

    implicit val jsonReadsGithubVisibility = new play.api.libs.json.Reads[io.flow.github.v0.models.Visibility] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.github.v0.models.Visibility] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.github.v0.models.Visibility(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.github.v0.models.Visibility(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesGithubVisibility(obj: io.flow.github.v0.models.Visibility) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectVisibility(obj: io.flow.github.v0.models.Visibility) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesGithubVisibility: play.api.libs.json.Writes[Visibility] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Visibility] {
        def writes(obj: io.flow.github.v0.models.Visibility) = {
          jsonWritesGithubVisibility(obj)
        }
      }
    }

    implicit def jsonReadsGithubBlob: play.api.libs.json.Reads[Blob] = {
      for {
        content <- (__ \ "content").read[String]
        encoding <- (__ \ "encoding").read[io.flow.github.v0.models.Encoding]
        url <- (__ \ "url").read[String]
        sha <- (__ \ "sha").read[String]
        size <- (__ \ "size").read[Long]
      } yield Blob(content, encoding, url, sha, size)
    }

    def jsObjectBlob(obj: io.flow.github.v0.models.Blob): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "content" -> play.api.libs.json.JsString(obj.content),
        "encoding" -> play.api.libs.json.JsString(obj.encoding.toString),
        "url" -> play.api.libs.json.JsString(obj.url),
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "size" -> play.api.libs.json.JsNumber(obj.size)
      )
    }

    implicit def jsonWritesGithubBlob: play.api.libs.json.Writes[Blob] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Blob] {
        def writes(obj: io.flow.github.v0.models.Blob) = {
          jsObjectBlob(obj)
        }
      }
    }

    implicit def jsonReadsGithubBlobCreated: play.api.libs.json.Reads[BlobCreated] = {
      for {
        url <- (__ \ "url").read[String]
        sha <- (__ \ "sha").read[String]
      } yield BlobCreated(url, sha)
    }

    def jsObjectBlobCreated(obj: io.flow.github.v0.models.BlobCreated): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "sha" -> play.api.libs.json.JsString(obj.sha)
      )
    }

    implicit def jsonWritesGithubBlobCreated: play.api.libs.json.Writes[BlobCreated] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.BlobCreated] {
        def writes(obj: io.flow.github.v0.models.BlobCreated) = {
          jsObjectBlobCreated(obj)
        }
      }
    }

    implicit def jsonReadsGithubBlobForm: play.api.libs.json.Reads[BlobForm] = {
      for {
        content <- (__ \ "content").read[String]
        encoding <- (__ \ "encoding").read[io.flow.github.v0.models.Encoding]
      } yield BlobForm(content, encoding)
    }

    def jsObjectBlobForm(obj: io.flow.github.v0.models.BlobForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "content" -> play.api.libs.json.JsString(obj.content),
        "encoding" -> play.api.libs.json.JsString(obj.encoding.toString)
      )
    }

    implicit def jsonWritesGithubBlobForm: play.api.libs.json.Writes[BlobForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.BlobForm] {
        def writes(obj: io.flow.github.v0.models.BlobForm) = {
          jsObjectBlobForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubCommit: play.api.libs.json.Reads[Commit] = {
      for {
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
        htmlUrl <- (__ \ "html_url").read[String]
        author <- (__ \ "author").read[io.flow.github.v0.models.Person]
        committer <- (__ \ "committer").read[io.flow.github.v0.models.Person]
        tree <- (__ \ "tree").read[io.flow.github.v0.models.TreeSummary]
        message <- (__ \ "message").read[String]
        parents <- (__ \ "parents").read[Seq[io.flow.github.v0.models.CommitSummary]]
      } yield Commit(sha, url, htmlUrl, author, committer, tree, message, parents)
    }

    def jsObjectCommit(obj: io.flow.github.v0.models.Commit): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url),
        "html_url" -> play.api.libs.json.JsString(obj.htmlUrl),
        "author" -> jsObjectPerson(obj.author),
        "committer" -> jsObjectPerson(obj.committer),
        "tree" -> jsObjectTreeSummary(obj.tree),
        "message" -> play.api.libs.json.JsString(obj.message),
        "parents" -> play.api.libs.json.Json.toJson(obj.parents)
      )
    }

    implicit def jsonWritesGithubCommit: play.api.libs.json.Writes[Commit] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Commit] {
        def writes(obj: io.flow.github.v0.models.Commit) = {
          jsObjectCommit(obj)
        }
      }
    }

    implicit def jsonReadsGithubCommitForm: play.api.libs.json.Reads[CommitForm] = {
      for {
        message <- (__ \ "message").read[String]
        tree <- (__ \ "tree").read[String]
        parents <- (__ \ "parents").read[Seq[String]]
        author <- (__ \ "author").read[io.flow.github.v0.models.Person]
        committer <- (__ \ "committer").read[io.flow.github.v0.models.Person]
      } yield CommitForm(message, tree, parents, author, committer)
    }

    def jsObjectCommitForm(obj: io.flow.github.v0.models.CommitForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "message" -> play.api.libs.json.JsString(obj.message),
        "tree" -> play.api.libs.json.JsString(obj.tree),
        "parents" -> play.api.libs.json.Json.toJson(obj.parents),
        "author" -> jsObjectPerson(obj.author),
        "committer" -> jsObjectPerson(obj.committer)
      )
    }

    implicit def jsonWritesGithubCommitForm: play.api.libs.json.Writes[CommitForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.CommitForm] {
        def writes(obj: io.flow.github.v0.models.CommitForm) = {
          jsObjectCommitForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubCommitResponse: play.api.libs.json.Reads[CommitResponse] = {
      for {
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
        author <- (__ \ "author").read[io.flow.github.v0.models.Person]
        committer <- (__ \ "committer").read[io.flow.github.v0.models.Person]
        message <- (__ \ "message").read[String]
        tree <- (__ \ "tree").read[io.flow.github.v0.models.TreeSummary]
        parents <- (__ \ "parents").read[Seq[io.flow.github.v0.models.TreeSummary]]
      } yield CommitResponse(sha, url, author, committer, message, tree, parents)
    }

    def jsObjectCommitResponse(obj: io.flow.github.v0.models.CommitResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url),
        "author" -> jsObjectPerson(obj.author),
        "committer" -> jsObjectPerson(obj.committer),
        "message" -> play.api.libs.json.JsString(obj.message),
        "tree" -> jsObjectTreeSummary(obj.tree),
        "parents" -> play.api.libs.json.Json.toJson(obj.parents)
      )
    }

    implicit def jsonWritesGithubCommitResponse: play.api.libs.json.Writes[CommitResponse] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.CommitResponse] {
        def writes(obj: io.flow.github.v0.models.CommitResponse) = {
          jsObjectCommitResponse(obj)
        }
      }
    }

    implicit def jsonReadsGithubCommitSummary: play.api.libs.json.Reads[CommitSummary] = {
      for {
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
      } yield CommitSummary(sha, url)
    }

    def jsObjectCommitSummary(obj: io.flow.github.v0.models.CommitSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url)
      )
    }

    implicit def jsonWritesGithubCommitSummary: play.api.libs.json.Writes[CommitSummary] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.CommitSummary] {
        def writes(obj: io.flow.github.v0.models.CommitSummary) = {
          jsObjectCommitSummary(obj)
        }
      }
    }

    implicit def jsonReadsGithubContents: play.api.libs.json.Reads[Contents] = {
      for {
        `type` <- (__ \ "type").read[io.flow.github.v0.models.ContentsType]
        encoding <- (__ \ "encoding").read[io.flow.github.v0.models.Encoding]
        size <- (__ \ "size").read[Long]
        name <- (__ \ "name").read[String]
        path <- (__ \ "path").read[String]
        content <- (__ \ "content").readNullable[String]
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
        gitUrl <- (__ \ "git_url").read[String]
        htmlUrl <- (__ \ "html_url").read[String]
        downloadUrl <- (__ \ "download_url").read[String]
      } yield Contents(`type`, encoding, size, name, path, content, sha, url, gitUrl, htmlUrl, downloadUrl)
    }

    def jsObjectContents(obj: io.flow.github.v0.models.Contents): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "encoding" -> play.api.libs.json.JsString(obj.encoding.toString),
        "size" -> play.api.libs.json.JsNumber(obj.size),
        "name" -> play.api.libs.json.JsString(obj.name),
        "path" -> play.api.libs.json.JsString(obj.path),
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url),
        "git_url" -> play.api.libs.json.JsString(obj.gitUrl),
        "html_url" -> play.api.libs.json.JsString(obj.htmlUrl),
        "download_url" -> play.api.libs.json.JsString(obj.downloadUrl)
      ) ++ (obj.content match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("content" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesGithubContents: play.api.libs.json.Writes[Contents] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Contents] {
        def writes(obj: io.flow.github.v0.models.Contents) = {
          jsObjectContents(obj)
        }
      }
    }

    implicit def jsonReadsGithubCreateTreeForm: play.api.libs.json.Reads[CreateTreeForm] = {
      for {
        baseTree <- (__ \ "base_tree").read[String]
        tree <- (__ \ "tree").read[Seq[io.flow.github.v0.models.TreeForm]]
      } yield CreateTreeForm(baseTree, tree)
    }

    def jsObjectCreateTreeForm(obj: io.flow.github.v0.models.CreateTreeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "base_tree" -> play.api.libs.json.JsString(obj.baseTree),
        "tree" -> play.api.libs.json.Json.toJson(obj.tree)
      )
    }

    implicit def jsonWritesGithubCreateTreeForm: play.api.libs.json.Writes[CreateTreeForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.CreateTreeForm] {
        def writes(obj: io.flow.github.v0.models.CreateTreeForm) = {
          jsObjectCreateTreeForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubCreateTreeResponse: play.api.libs.json.Reads[CreateTreeResponse] = {
      for {
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
        treeResult <- (__ \ "tree_result").read[io.flow.github.v0.models.Tree]
      } yield CreateTreeResponse(sha, url, treeResult)
    }

    def jsObjectCreateTreeResponse(obj: io.flow.github.v0.models.CreateTreeResponse): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url),
        "tree_result" -> jsObjectTree(obj.treeResult)
      )
    }

    implicit def jsonWritesGithubCreateTreeResponse: play.api.libs.json.Writes[CreateTreeResponse] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.CreateTreeResponse] {
        def writes(obj: io.flow.github.v0.models.CreateTreeResponse) = {
          jsObjectCreateTreeResponse(obj)
        }
      }
    }

    implicit def jsonReadsGithubError: play.api.libs.json.Reads[Error] = {
      for {
        resource <- (__ \ "resource").read[String]
        field <- (__ \ "field").read[String]
        code <- (__ \ "code").read[String]
      } yield Error(resource, field, code)
    }

    def jsObjectError(obj: io.flow.github.v0.models.Error): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "resource" -> play.api.libs.json.JsString(obj.resource),
        "field" -> play.api.libs.json.JsString(obj.field),
        "code" -> play.api.libs.json.JsString(obj.code)
      )
    }

    implicit def jsonWritesGithubError: play.api.libs.json.Writes[Error] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Error] {
        def writes(obj: io.flow.github.v0.models.Error) = {
          jsObjectError(obj)
        }
      }
    }

    implicit def jsonReadsGithubGithubObject: play.api.libs.json.Reads[GithubObject] = {
      for {
        `type` <- (__ \ "type").read[String]
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
      } yield GithubObject(`type`, sha, url)
    }

    def jsObjectGithubObject(obj: io.flow.github.v0.models.GithubObject): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`),
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url)
      )
    }

    implicit def jsonWritesGithubGithubObject: play.api.libs.json.Writes[GithubObject] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.GithubObject] {
        def writes(obj: io.flow.github.v0.models.GithubObject) = {
          jsObjectGithubObject(obj)
        }
      }
    }

    implicit def jsonReadsGithubHook: play.api.libs.json.Reads[Hook] = {
      for {
        id <- (__ \ "id").read[Long]
        url <- (__ \ "url").read[String]
        testUrl <- (__ \ "test_url").read[String]
        pingUrl <- (__ \ "ping_url").read[String]
        name <- (__ \ "name").read[String]
        events <- (__ \ "events").read[Seq[io.flow.github.v0.models.HookEvent]]
        active <- (__ \ "active").read[Boolean]
        config <- (__ \ "config").read[io.flow.github.v0.models.HookConfig]
        updatedAt <- (__ \ "updated_at").read[_root_.org.joda.time.DateTime]
        createdAt <- (__ \ "created_at").read[_root_.org.joda.time.DateTime]
      } yield Hook(id, url, testUrl, pingUrl, name, events, active, config, updatedAt, createdAt)
    }

    def jsObjectHook(obj: io.flow.github.v0.models.Hook): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "url" -> play.api.libs.json.JsString(obj.url),
        "test_url" -> play.api.libs.json.JsString(obj.testUrl),
        "ping_url" -> play.api.libs.json.JsString(obj.pingUrl),
        "name" -> play.api.libs.json.JsString(obj.name),
        "events" -> play.api.libs.json.Json.toJson(obj.events),
        "active" -> play.api.libs.json.JsBoolean(obj.active),
        "config" -> jsObjectHookConfig(obj.config),
        "updated_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.updatedAt)),
        "created_at" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.createdAt))
      )
    }

    implicit def jsonWritesGithubHook: play.api.libs.json.Writes[Hook] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Hook] {
        def writes(obj: io.flow.github.v0.models.Hook) = {
          jsObjectHook(obj)
        }
      }
    }

    implicit def jsonReadsGithubHookConfig: play.api.libs.json.Reads[HookConfig] = {
      for {
        url <- (__ \ "url").readNullable[String]
        contentType <- (__ \ "content_type").readNullable[String]
      } yield HookConfig(url, contentType)
    }

    def jsObjectHookConfig(obj: io.flow.github.v0.models.HookConfig): play.api.libs.json.JsObject = {
      (obj.url match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("url" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.contentType match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("content_type" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesGithubHookConfig: play.api.libs.json.Writes[HookConfig] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.HookConfig] {
        def writes(obj: io.flow.github.v0.models.HookConfig) = {
          jsObjectHookConfig(obj)
        }
      }
    }

    implicit def jsonReadsGithubHookForm: play.api.libs.json.Reads[HookForm] = {
      for {
        name <- (__ \ "name").read[String]
        config <- (__ \ "config").read[io.flow.github.v0.models.HookConfig]
        events <- (__ \ "events").read[Seq[io.flow.github.v0.models.HookEvent]]
        active <- (__ \ "active").read[Boolean]
      } yield HookForm(name, config, events, active)
    }

    def jsObjectHookForm(obj: io.flow.github.v0.models.HookForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "config" -> jsObjectHookConfig(obj.config),
        "events" -> play.api.libs.json.Json.toJson(obj.events),
        "active" -> play.api.libs.json.JsBoolean(obj.active)
      )
    }

    implicit def jsonWritesGithubHookForm: play.api.libs.json.Writes[HookForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.HookForm] {
        def writes(obj: io.flow.github.v0.models.HookForm) = {
          jsObjectHookForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubNode: play.api.libs.json.Reads[Node] = {
      for {
        path <- (__ \ "path").read[String]
        mode <- (__ \ "mode").read[String]
        `type` <- (__ \ "type").read[io.flow.github.v0.models.NodeType]
        size <- (__ \ "size").read[Long]
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
      } yield Node(path, mode, `type`, size, sha, url)
    }

    def jsObjectNode(obj: io.flow.github.v0.models.Node): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "path" -> play.api.libs.json.JsString(obj.path),
        "mode" -> play.api.libs.json.JsString(obj.mode),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "size" -> play.api.libs.json.JsNumber(obj.size),
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url)
      )
    }

    implicit def jsonWritesGithubNode: play.api.libs.json.Writes[Node] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Node] {
        def writes(obj: io.flow.github.v0.models.Node) = {
          jsObjectNode(obj)
        }
      }
    }

    implicit def jsonReadsGithubNodeForm: play.api.libs.json.Reads[NodeForm] = {
      for {
        path <- (__ \ "path").read[String]
        mode <- (__ \ "mode").read[String]
        `type` <- (__ \ "type").read[io.flow.github.v0.models.NodeType]
        sha <- (__ \ "sha").read[String]
      } yield NodeForm(path, mode, `type`, sha)
    }

    def jsObjectNodeForm(obj: io.flow.github.v0.models.NodeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "path" -> play.api.libs.json.JsString(obj.path),
        "mode" -> play.api.libs.json.JsString(obj.mode),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "sha" -> play.api.libs.json.JsString(obj.sha)
      )
    }

    implicit def jsonWritesGithubNodeForm: play.api.libs.json.Writes[NodeForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.NodeForm] {
        def writes(obj: io.flow.github.v0.models.NodeForm) = {
          jsObjectNodeForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubPerson: play.api.libs.json.Reads[Person] = {
      for {
        name <- (__ \ "name").read[String]
        email <- (__ \ "email").read[String]
        date <- (__ \ "date").read[_root_.org.joda.time.DateTime]
      } yield Person(name, email, date)
    }

    def jsObjectPerson(obj: io.flow.github.v0.models.Person): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "email" -> play.api.libs.json.JsString(obj.email),
        "date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.date))
      )
    }

    implicit def jsonWritesGithubPerson: play.api.libs.json.Writes[Person] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Person] {
        def writes(obj: io.flow.github.v0.models.Person) = {
          jsObjectPerson(obj)
        }
      }
    }

    implicit def jsonReadsGithubPullRequest: play.api.libs.json.Reads[PullRequest] = {
      for {
        id <- (__ \ "id").read[Long]
        url <- (__ \ "url").read[String]
        number <- (__ \ "number").read[Long]
        htmlUrl <- (__ \ "html_url").read[String]
        head <- (__ \ "head").read[io.flow.github.v0.models.PullRequestHead]
      } yield PullRequest(id, url, number, htmlUrl, head)
    }

    def jsObjectPullRequest(obj: io.flow.github.v0.models.PullRequest): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "url" -> play.api.libs.json.JsString(obj.url),
        "number" -> play.api.libs.json.JsNumber(obj.number),
        "html_url" -> play.api.libs.json.JsString(obj.htmlUrl),
        "head" -> jsObjectPullRequestHead(obj.head)
      )
    }

    implicit def jsonWritesGithubPullRequest: play.api.libs.json.Writes[PullRequest] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.PullRequest] {
        def writes(obj: io.flow.github.v0.models.PullRequest) = {
          jsObjectPullRequest(obj)
        }
      }
    }

    implicit def jsonReadsGithubPullRequestForm: play.api.libs.json.Reads[PullRequestForm] = {
      for {
        title <- (__ \ "title").read[String]
        head <- (__ \ "head").read[String]
        base <- (__ \ "base").read[String]
        body <- (__ \ "body").readNullable[String]
      } yield PullRequestForm(title, head, base, body)
    }

    def jsObjectPullRequestForm(obj: io.flow.github.v0.models.PullRequestForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "title" -> play.api.libs.json.JsString(obj.title),
        "head" -> play.api.libs.json.JsString(obj.head),
        "base" -> play.api.libs.json.JsString(obj.base)
      ) ++ (obj.body match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("body" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesGithubPullRequestForm: play.api.libs.json.Writes[PullRequestForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.PullRequestForm] {
        def writes(obj: io.flow.github.v0.models.PullRequestForm) = {
          jsObjectPullRequestForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubPullRequestHead: play.api.libs.json.Reads[PullRequestHead] = {
      (__ \ "ref").read[String].map { x => new PullRequestHead(ref = x) }
    }

    def jsObjectPullRequestHead(obj: io.flow.github.v0.models.PullRequestHead): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "ref" -> play.api.libs.json.JsString(obj.ref)
      )
    }

    implicit def jsonWritesGithubPullRequestHead: play.api.libs.json.Writes[PullRequestHead] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.PullRequestHead] {
        def writes(obj: io.flow.github.v0.models.PullRequestHead) = {
          jsObjectPullRequestHead(obj)
        }
      }
    }

    implicit def jsonReadsGithubRef: play.api.libs.json.Reads[Ref] = {
      for {
        ref <- (__ \ "ref").read[String]
        url <- (__ \ "url").read[String]
        `object` <- (__ \ "object").read[io.flow.github.v0.models.GithubObject]
      } yield Ref(ref, url, `object`)
    }

    def jsObjectRef(obj: io.flow.github.v0.models.Ref): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "ref" -> play.api.libs.json.JsString(obj.ref),
        "url" -> play.api.libs.json.JsString(obj.url),
        "object" -> jsObjectGithubObject(obj.`object`)
      )
    }

    implicit def jsonWritesGithubRef: play.api.libs.json.Writes[Ref] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Ref] {
        def writes(obj: io.flow.github.v0.models.Ref) = {
          jsObjectRef(obj)
        }
      }
    }

    implicit def jsonReadsGithubRefForm: play.api.libs.json.Reads[RefForm] = {
      for {
        ref <- (__ \ "ref").read[String]
        sha <- (__ \ "sha").read[String]
      } yield RefForm(ref, sha)
    }

    def jsObjectRefForm(obj: io.flow.github.v0.models.RefForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "ref" -> play.api.libs.json.JsString(obj.ref),
        "sha" -> play.api.libs.json.JsString(obj.sha)
      )
    }

    implicit def jsonWritesGithubRefForm: play.api.libs.json.Writes[RefForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.RefForm] {
        def writes(obj: io.flow.github.v0.models.RefForm) = {
          jsObjectRefForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubRefUpdateForm: play.api.libs.json.Reads[RefUpdateForm] = {
      (__ \ "sha").read[String].map { x => new RefUpdateForm(sha = x) }
    }

    def jsObjectRefUpdateForm(obj: io.flow.github.v0.models.RefUpdateForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "sha" -> play.api.libs.json.JsString(obj.sha)
      )
    }

    implicit def jsonWritesGithubRefUpdateForm: play.api.libs.json.Writes[RefUpdateForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.RefUpdateForm] {
        def writes(obj: io.flow.github.v0.models.RefUpdateForm) = {
          jsObjectRefUpdateForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubRepository: play.api.libs.json.Reads[Repository] = {
      for {
        id <- (__ \ "id").read[Long]
        owner <- (__ \ "owner").read[io.flow.github.v0.models.User]
        name <- (__ \ "name").read[String]
        fullName <- (__ \ "full_name").read[String]
        `private` <- (__ \ "private").read[Boolean]
        description <- (__ \ "description").readNullable[String]
        url <- (__ \ "url").read[String]
        htmlUrl <- (__ \ "html_url").read[String]
      } yield Repository(id, owner, name, fullName, `private`, description, url, htmlUrl)
    }

    def jsObjectRepository(obj: io.flow.github.v0.models.Repository): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "owner" -> jsObjectUser(obj.owner),
        "name" -> play.api.libs.json.JsString(obj.name),
        "full_name" -> play.api.libs.json.JsString(obj.fullName),
        "private" -> play.api.libs.json.JsBoolean(obj.`private`),
        "url" -> play.api.libs.json.JsString(obj.url),
        "html_url" -> play.api.libs.json.JsString(obj.htmlUrl)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesGithubRepository: play.api.libs.json.Writes[Repository] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Repository] {
        def writes(obj: io.flow.github.v0.models.Repository) = {
          jsObjectRepository(obj)
        }
      }
    }

    implicit def jsonReadsGithubTag: play.api.libs.json.Reads[Tag] = {
      for {
        tag <- (__ \ "tag").read[String]
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
        message <- (__ \ "message").read[String]
        tagger <- (__ \ "tagger").read[io.flow.github.v0.models.Tagger]
        `object` <- (__ \ "object").read[io.flow.github.v0.models.GithubObject]
      } yield Tag(tag, sha, url, message, tagger, `object`)
    }

    def jsObjectTag(obj: io.flow.github.v0.models.Tag): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tag" -> play.api.libs.json.JsString(obj.tag),
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url),
        "message" -> play.api.libs.json.JsString(obj.message),
        "tagger" -> jsObjectTagger(obj.tagger),
        "object" -> jsObjectGithubObject(obj.`object`)
      )
    }

    implicit def jsonWritesGithubTag: play.api.libs.json.Writes[Tag] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Tag] {
        def writes(obj: io.flow.github.v0.models.Tag) = {
          jsObjectTag(obj)
        }
      }
    }

    implicit def jsonReadsGithubTagForm: play.api.libs.json.Reads[TagForm] = {
      for {
        tag <- (__ \ "tag").read[String]
        message <- (__ \ "message").read[String]
        `object` <- (__ \ "object").read[String]
        `type` <- (__ \ "type").read[String]
        tagger <- (__ \ "tagger").read[io.flow.github.v0.models.Tagger]
      } yield TagForm(tag, message, `object`, `type`, tagger)
    }

    def jsObjectTagForm(obj: io.flow.github.v0.models.TagForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "tag" -> play.api.libs.json.JsString(obj.tag),
        "message" -> play.api.libs.json.JsString(obj.message),
        "object" -> play.api.libs.json.JsString(obj.`object`),
        "type" -> play.api.libs.json.JsString(obj.`type`),
        "tagger" -> jsObjectTagger(obj.tagger)
      )
    }

    implicit def jsonWritesGithubTagForm: play.api.libs.json.Writes[TagForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.TagForm] {
        def writes(obj: io.flow.github.v0.models.TagForm) = {
          jsObjectTagForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubTagSummary: play.api.libs.json.Reads[TagSummary] = {
      for {
        name <- (__ \ "name").read[String]
        commit <- (__ \ "commit").read[io.flow.github.v0.models.CommitSummary]
      } yield TagSummary(name, commit)
    }

    def jsObjectTagSummary(obj: io.flow.github.v0.models.TagSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "commit" -> jsObjectCommitSummary(obj.commit)
      )
    }

    implicit def jsonWritesGithubTagSummary: play.api.libs.json.Writes[TagSummary] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.TagSummary] {
        def writes(obj: io.flow.github.v0.models.TagSummary) = {
          jsObjectTagSummary(obj)
        }
      }
    }

    implicit def jsonReadsGithubTagger: play.api.libs.json.Reads[Tagger] = {
      for {
        name <- (__ \ "name").read[String]
        email <- (__ \ "email").read[String]
        date <- (__ \ "date").read[_root_.org.joda.time.DateTime]
      } yield Tagger(name, email, date)
    }

    def jsObjectTagger(obj: io.flow.github.v0.models.Tagger): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "email" -> play.api.libs.json.JsString(obj.email),
        "date" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.date))
      )
    }

    implicit def jsonWritesGithubTagger: play.api.libs.json.Writes[Tagger] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Tagger] {
        def writes(obj: io.flow.github.v0.models.Tagger) = {
          jsObjectTagger(obj)
        }
      }
    }

    implicit def jsonReadsGithubTree: play.api.libs.json.Reads[Tree] = {
      for {
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
        truncated <- (__ \ "truncated").read[Boolean]
        tree <- (__ \ "tree").read[Seq[io.flow.github.v0.models.Node]]
      } yield Tree(sha, url, truncated, tree)
    }

    def jsObjectTree(obj: io.flow.github.v0.models.Tree): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url),
        "truncated" -> play.api.libs.json.JsBoolean(obj.truncated),
        "tree" -> play.api.libs.json.Json.toJson(obj.tree)
      )
    }

    implicit def jsonWritesGithubTree: play.api.libs.json.Writes[Tree] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.Tree] {
        def writes(obj: io.flow.github.v0.models.Tree) = {
          jsObjectTree(obj)
        }
      }
    }

    implicit def jsonReadsGithubTreeForm: play.api.libs.json.Reads[TreeForm] = {
      for {
        path <- (__ \ "path").read[String]
        mode <- (__ \ "mode").read[String]
        `type` <- (__ \ "type").read[io.flow.github.v0.models.NodeType]
        sha <- (__ \ "sha").readNullable[String]
        content <- (__ \ "content").readNullable[String]
      } yield TreeForm(path, mode, `type`, sha, content)
    }

    def jsObjectTreeForm(obj: io.flow.github.v0.models.TreeForm): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "path" -> play.api.libs.json.JsString(obj.path),
        "mode" -> play.api.libs.json.JsString(obj.mode),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.sha match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("sha" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.content match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("content" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesGithubTreeForm: play.api.libs.json.Writes[TreeForm] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.TreeForm] {
        def writes(obj: io.flow.github.v0.models.TreeForm) = {
          jsObjectTreeForm(obj)
        }
      }
    }

    implicit def jsonReadsGithubTreeResult: play.api.libs.json.Reads[TreeResult] = {
      for {
        path <- (__ \ "path").read[String]
        mode <- (__ \ "mode").read[String]
        `type` <- (__ \ "type").read[io.flow.github.v0.models.NodeType]
        size <- (__ \ "size").read[Long]
        sha <- (__ \ "sha").read[String]
        url <- (__ \ "url").read[String]
      } yield TreeResult(path, mode, `type`, size, sha, url)
    }

    def jsObjectTreeResult(obj: io.flow.github.v0.models.TreeResult): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "path" -> play.api.libs.json.JsString(obj.path),
        "mode" -> play.api.libs.json.JsString(obj.mode),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString),
        "size" -> play.api.libs.json.JsNumber(obj.size),
        "sha" -> play.api.libs.json.JsString(obj.sha),
        "url" -> play.api.libs.json.JsString(obj.url)
      )
    }

    implicit def jsonWritesGithubTreeResult: play.api.libs.json.Writes[TreeResult] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.TreeResult] {
        def writes(obj: io.flow.github.v0.models.TreeResult) = {
          jsObjectTreeResult(obj)
        }
      }
    }

    implicit def jsonReadsGithubTreeSummary: play.api.libs.json.Reads[TreeSummary] = {
      for {
        url <- (__ \ "url").read[String]
        sha <- (__ \ "sha").read[String]
      } yield TreeSummary(url, sha)
    }

    def jsObjectTreeSummary(obj: io.flow.github.v0.models.TreeSummary): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "url" -> play.api.libs.json.JsString(obj.url),
        "sha" -> play.api.libs.json.JsString(obj.sha)
      )
    }

    implicit def jsonWritesGithubTreeSummary: play.api.libs.json.Writes[TreeSummary] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.TreeSummary] {
        def writes(obj: io.flow.github.v0.models.TreeSummary) = {
          jsObjectTreeSummary(obj)
        }
      }
    }

    implicit def jsonReadsGithubUnprocessableEntity: play.api.libs.json.Reads[UnprocessableEntity] = {
      for {
        message <- (__ \ "message").read[String]
        errors <- (__ \ "errors").readNullable[Seq[io.flow.github.v0.models.Error]]
      } yield UnprocessableEntity(message, errors)
    }

    def jsObjectUnprocessableEntity(obj: io.flow.github.v0.models.UnprocessableEntity): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "message" -> play.api.libs.json.JsString(obj.message)
      ) ++ (obj.errors match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("errors" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesGithubUnprocessableEntity: play.api.libs.json.Writes[UnprocessableEntity] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.UnprocessableEntity] {
        def writes(obj: io.flow.github.v0.models.UnprocessableEntity) = {
          jsObjectUnprocessableEntity(obj)
        }
      }
    }

    implicit def jsonReadsGithubUser: play.api.libs.json.Reads[User] = {
      for {
        id <- (__ \ "id").read[Long]
        login <- (__ \ "login").read[String]
        name <- (__ \ "name").readNullable[String]
        email <- (__ \ "email").readNullable[String]
        avatarUrl <- (__ \ "avatar_url").readNullable[String]
        gravatarId <- (__ \ "gravatar_id").readNullable[String]
        url <- (__ \ "url").read[String]
        htmlUrl <- (__ \ "html_url").read[String]
        `type` <- (__ \ "type").read[io.flow.github.v0.models.OwnerType]
      } yield User(id, login, name, email, avatarUrl, gravatarId, url, htmlUrl, `type`)
    }

    def jsObjectUser(obj: io.flow.github.v0.models.User): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "id" -> play.api.libs.json.JsNumber(obj.id),
        "login" -> play.api.libs.json.JsString(obj.login),
        "url" -> play.api.libs.json.JsString(obj.url),
        "html_url" -> play.api.libs.json.JsString(obj.htmlUrl),
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.email match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("email" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.avatarUrl match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("avatar_url" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.gravatarId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("gravatar_id" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesGithubUser: play.api.libs.json.Writes[User] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.User] {
        def writes(obj: io.flow.github.v0.models.User) = {
          jsObjectUser(obj)
        }
      }
    }

    implicit def jsonReadsGithubUserEmail: play.api.libs.json.Reads[UserEmail] = {
      for {
        email <- (__ \ "email").read[String]
        verified <- (__ \ "verified").read[Boolean]
        primary <- (__ \ "primary").read[Boolean]
      } yield UserEmail(email, verified, primary)
    }

    def jsObjectUserEmail(obj: io.flow.github.v0.models.UserEmail): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "email" -> play.api.libs.json.JsString(obj.email),
        "verified" -> play.api.libs.json.JsBoolean(obj.verified),
        "primary" -> play.api.libs.json.JsBoolean(obj.primary)
      )
    }

    implicit def jsonWritesGithubUserEmail: play.api.libs.json.Writes[UserEmail] = {
      new play.api.libs.json.Writes[io.flow.github.v0.models.UserEmail] {
        def writes(obj: io.flow.github.v0.models.UserEmail) = {
          jsObjectUserEmail(obj)
        }
      }
    }
  }
}

package io.flow.github.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.github.v0.models._

      val contentsTypeConverter: ApibuilderTypeConverter[io.flow.github.v0.models.ContentsType] = new ApibuilderTypeConverter[io.flow.github.v0.models.ContentsType] {
        override def convert(value: String): io.flow.github.v0.models.ContentsType = io.flow.github.v0.models.ContentsType(value)
        override def convert(value: io.flow.github.v0.models.ContentsType): String = value.toString
        override def example: io.flow.github.v0.models.ContentsType = io.flow.github.v0.models.ContentsType.File
        override def validValues: Seq[io.flow.github.v0.models.ContentsType] = io.flow.github.v0.models.ContentsType.all
      }
      implicit def pathBindableContentsType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.github.v0.models.ContentsType] = ApibuilderPathBindable(contentsTypeConverter)
      implicit def queryStringBindableContentsType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.github.v0.models.ContentsType] = ApibuilderQueryStringBindable(contentsTypeConverter)

      val encodingConverter: ApibuilderTypeConverter[io.flow.github.v0.models.Encoding] = new ApibuilderTypeConverter[io.flow.github.v0.models.Encoding] {
        override def convert(value: String): io.flow.github.v0.models.Encoding = io.flow.github.v0.models.Encoding(value)
        override def convert(value: io.flow.github.v0.models.Encoding): String = value.toString
        override def example: io.flow.github.v0.models.Encoding = io.flow.github.v0.models.Encoding.Base64
        override def validValues: Seq[io.flow.github.v0.models.Encoding] = io.flow.github.v0.models.Encoding.all
      }
      implicit def pathBindableEncoding(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.github.v0.models.Encoding] = ApibuilderPathBindable(encodingConverter)
      implicit def queryStringBindableEncoding(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.github.v0.models.Encoding] = ApibuilderQueryStringBindable(encodingConverter)

      val hookEventConverter: ApibuilderTypeConverter[io.flow.github.v0.models.HookEvent] = new ApibuilderTypeConverter[io.flow.github.v0.models.HookEvent] {
        override def convert(value: String): io.flow.github.v0.models.HookEvent = io.flow.github.v0.models.HookEvent(value)
        override def convert(value: io.flow.github.v0.models.HookEvent): String = value.toString
        override def example: io.flow.github.v0.models.HookEvent = io.flow.github.v0.models.HookEvent.Push
        override def validValues: Seq[io.flow.github.v0.models.HookEvent] = io.flow.github.v0.models.HookEvent.all
      }
      implicit def pathBindableHookEvent(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.github.v0.models.HookEvent] = ApibuilderPathBindable(hookEventConverter)
      implicit def queryStringBindableHookEvent(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.github.v0.models.HookEvent] = ApibuilderQueryStringBindable(hookEventConverter)

      val nodeTypeConverter: ApibuilderTypeConverter[io.flow.github.v0.models.NodeType] = new ApibuilderTypeConverter[io.flow.github.v0.models.NodeType] {
        override def convert(value: String): io.flow.github.v0.models.NodeType = io.flow.github.v0.models.NodeType(value)
        override def convert(value: io.flow.github.v0.models.NodeType): String = value.toString
        override def example: io.flow.github.v0.models.NodeType = io.flow.github.v0.models.NodeType.Blob
        override def validValues: Seq[io.flow.github.v0.models.NodeType] = io.flow.github.v0.models.NodeType.all
      }
      implicit def pathBindableNodeType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.github.v0.models.NodeType] = ApibuilderPathBindable(nodeTypeConverter)
      implicit def queryStringBindableNodeType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.github.v0.models.NodeType] = ApibuilderQueryStringBindable(nodeTypeConverter)

      val ownerTypeConverter: ApibuilderTypeConverter[io.flow.github.v0.models.OwnerType] = new ApibuilderTypeConverter[io.flow.github.v0.models.OwnerType] {
        override def convert(value: String): io.flow.github.v0.models.OwnerType = io.flow.github.v0.models.OwnerType(value)
        override def convert(value: io.flow.github.v0.models.OwnerType): String = value.toString
        override def example: io.flow.github.v0.models.OwnerType = io.flow.github.v0.models.OwnerType.User
        override def validValues: Seq[io.flow.github.v0.models.OwnerType] = io.flow.github.v0.models.OwnerType.all
      }
      implicit def pathBindableOwnerType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.github.v0.models.OwnerType] = ApibuilderPathBindable(ownerTypeConverter)
      implicit def queryStringBindableOwnerType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.github.v0.models.OwnerType] = ApibuilderQueryStringBindable(ownerTypeConverter)

      val visibilityConverter: ApibuilderTypeConverter[io.flow.github.v0.models.Visibility] = new ApibuilderTypeConverter[io.flow.github.v0.models.Visibility] {
        override def convert(value: String): io.flow.github.v0.models.Visibility = io.flow.github.v0.models.Visibility(value)
        override def convert(value: io.flow.github.v0.models.Visibility): String = value.toString
        override def example: io.flow.github.v0.models.Visibility = io.flow.github.v0.models.Visibility.All
        override def validValues: Seq[io.flow.github.v0.models.Visibility] = io.flow.github.v0.models.Visibility.all
      }
      implicit def pathBindableVisibility(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.github.v0.models.Visibility] = ApibuilderPathBindable(visibilityConverter)
      implicit def queryStringBindableVisibility(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.github.v0.models.Visibility] = ApibuilderQueryStringBindable(visibilityConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      val dateTimeIso8601: ApibuilderTypeConverter[_root_.org.joda.time.DateTime] = new ApibuilderTypeConverter[_root_.org.joda.time.DateTime] {
        override def convert(value: String): _root_.org.joda.time.DateTime = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: _root_.org.joda.time.DateTime): String = _root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(value)
        override def example: _root_.org.joda.time.DateTime = _root_.org.joda.time.DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] = new ApibuilderTypeConverter[_root_.org.joda.time.LocalDate] {
        override def convert(value: String): _root_.org.joda.time.LocalDate = _root_.org.joda.time.format.ISODateTimeFormat.dateTimeParser.parseLocalDate(value)
        override def convert(value: _root_.org.joda.time.LocalDate): String = _root_.org.joda.time.format.ISODateTimeFormat.date.print(value)
        override def example: _root_.org.joda.time.LocalDate = _root_.org.joda.time.LocalDate.now
      }
    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}


package io.flow.github.v0 {

  object Constants {

    val BaseUrl = "https://api.github.com"
    val Namespace = "io.flow.github.v0"
    val UserAgent = "apibuilder 0.14.75 app.apibuilder.io/flow/github/0.2.10/play_2_6_client"
    val Version = "0.2.10"
    val VersionMajor = 0

  }

  class Client(
    ws: play.api.libs.ws.WSClient,
    val baseUrl: String = "https://api.github.com",
    auth: scala.Option[io.flow.github.v0.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil
  ) extends interfaces.Client {
    import io.flow.github.v0.models.json._

    private[this] val logger = play.api.Logger("io.flow.github.v0.Client")

    logger.info(s"Initializing io.flow.github.v0.Client for url $baseUrl")

    def blobs: Blobs = Blobs

    def commits: Commits = Commits

    def contents: Contents = Contents

    def hooks: Hooks = Hooks

    def pullRequests: PullRequests = PullRequests

    def refs: Refs = Refs

    def repositories: Repositories = Repositories

    def tags: Tags = Tags

    def trees: Trees = Trees

    def userEmails: UserEmails = UserEmails

    def users: Users = Users

    object Blobs extends Blobs {
      override def getBySha(
        owner: String,
        repo: String,
        sha: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Blob] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/blobs/${play.utils.UriEncoding.encodePathSegment(sha, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Blob", r, _.validate[io.flow.github.v0.models.Blob])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def post(
        owner: String,
        repo: String,
        blobForm: io.flow.github.v0.models.BlobForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.BlobCreated] = {
        val payload = play.api.libs.json.Json.toJson(blobForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/blobs", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.BlobCreated", r, _.validate[io.flow.github.v0.models.BlobCreated])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }
    }

    object Commits extends Commits {
      override def getBySha(
        owner: String,
        repo: String,
        sha: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Commit] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/commits/${play.utils.UriEncoding.encodePathSegment(sha, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Commit", r, _.validate[io.flow.github.v0.models.Commit])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404, 422")
        }
      }

      override def post(
        owner: String,
        repo: String,
        commitForm: io.flow.github.v0.models.CommitForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.CommitResponse] = {
        val payload = play.api.libs.json.Json.toJson(commitForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/commits", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.CommitResponse", r, _.validate[io.flow.github.v0.models.CommitResponse])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }
    }

    object Contents extends Contents {
      override def getReadme(
        owner: String,
        repo: String,
        ref: String = "master",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Contents] = {
        val queryParameters = Seq(
          Some("ref" -> ref)
        ).flatten

        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/readme", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Contents", r, _.validate[io.flow.github.v0.models.Contents])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }

      override def getContentsByPath(
        owner: String,
        repo: String,
        path: String,
        ref: String = "master",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Contents] = {
        val queryParameters = Seq(
          Some("ref" -> ref)
        ).flatten

        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/contents/${play.utils.UriEncoding.encodePathSegment(path, "UTF-8")}", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Contents", r, _.validate[io.flow.github.v0.models.Contents])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401, 404")
        }
      }
    }

    object Hooks extends Hooks {
      override def get(
        owner: String,
        repo: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Hook]] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/hooks", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.Hook]", r, _.validate[Seq[io.flow.github.v0.models.Hook]])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def getById(
        owner: String,
        repo: String,
        id: Long,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Hook] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/hooks/${id}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Hook", r, _.validate[io.flow.github.v0.models.Hook])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def post(
        owner: String,
        repo: String,
        hookForm: io.flow.github.v0.models.HookForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Hook] = {
        val payload = play.api.libs.json.Json.toJson(hookForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/hooks", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Hook", r, _.validate[io.flow.github.v0.models.Hook])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }

      override def deleteById(
        owner: String,
        repo: String,
        id: Long,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit] = {
        _executeRequest("DELETE", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/hooks/${id}", requestHeaders = requestHeaders).map {
          case r if r.status == 204 => ()
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 204, 404")
        }
      }
    }

    object PullRequests extends PullRequests {
      override def post(
        owner: String,
        repo: String,
        pullRequestForm: io.flow.github.v0.models.PullRequestForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.PullRequest] = {
        val payload = play.api.libs.json.Json.toJson(pullRequestForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/pulls", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.PullRequest", r, _.validate[io.flow.github.v0.models.PullRequest])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }

      override def get(
        owner: String,
        repo: String,
        page: Long = 1L,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.PullRequest]] = {
        val queryParameters = Seq(
          Some("page" -> page.toString)
        ).flatten

        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/pulls", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.PullRequest]", r, _.validate[Seq[io.flow.github.v0.models.PullRequest]])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }
    }

    object Refs extends Refs {
      override def get(
        owner: String,
        repo: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Ref]] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/refs", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.Ref]", r, _.validate[Seq[io.flow.github.v0.models.Ref]])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def getByRef(
        owner: String,
        repo: String,
        ref: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Ref] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/refs/${play.utils.UriEncoding.encodePathSegment(ref, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Ref", r, _.validate[io.flow.github.v0.models.Ref])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def post(
        owner: String,
        repo: String,
        refForm: io.flow.github.v0.models.RefForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Ref] = {
        val payload = play.api.libs.json.Json.toJson(refForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/refs", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Ref", r, _.validate[io.flow.github.v0.models.Ref])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }

      override def putByRef(
        owner: String,
        repo: String,
        ref: String,
        refUpdateForm: io.flow.github.v0.models.RefUpdateForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Ref] = {
        val payload = play.api.libs.json.Json.toJson(refUpdateForm)

        _executeRequest("PUT", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/refs/${play.utils.UriEncoding.encodePathSegment(ref, "UTF-8")}", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Ref", r, _.validate[io.flow.github.v0.models.Ref])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }
    }

    object Repositories extends Repositories {
      override def getUserAndRepos(
        page: Long = 1L,
        visibility: io.flow.github.v0.models.Visibility = io.flow.github.v0.models.Visibility.All,
        affiliation: _root_.scala.Option[String] = None,
        `type`: _root_.scala.Option[String] = None,
        sort: String = "full_name",
        direction: String = "asc",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Repository]] = {
        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("visibility" -> visibility.toString),
          affiliation.map("affiliation" -> _),
          `type`.map("type" -> _),
          Some("sort" -> sort),
          Some("direction" -> direction)
        ).flatten

        _executeRequest("GET", s"/user/repos", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.Repository]", r, _.validate[Seq[io.flow.github.v0.models.Repository]])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401")
        }
      }

      override def getUsersAndReposByUsername(
        username: String,
        page: Long = 1L,
        `type`: String = "owner",
        sort: String = "full_name",
        direction: String = "asc",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Repository]] = {
        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("type" -> `type`),
          Some("sort" -> sort),
          Some("direction" -> direction)
        ).flatten

        _executeRequest("GET", s"/users/${play.utils.UriEncoding.encodePathSegment(username, "UTF-8")}/repos", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.Repository]", r, _.validate[Seq[io.flow.github.v0.models.Repository]])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401")
        }
      }

      override def getOrgsAndReposByOrg(
        org: String,
        page: Long = 1L,
        `type`: String = "all",
        sort: String = "full_name",
        direction: String = "asc",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Repository]] = {
        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("type" -> `type`),
          Some("sort" -> sort),
          Some("direction" -> direction)
        ).flatten

        _executeRequest("GET", s"/orgs/${play.utils.UriEncoding.encodePathSegment(org, "UTF-8")}/repos", queryParameters = queryParameters, requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.Repository]", r, _.validate[Seq[io.flow.github.v0.models.Repository]])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401")
        }
      }
    }

    object Tags extends Tags {
      override def getTags(
        owner: String,
        repo: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.TagSummary]] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/tags", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.TagSummary]", r, _.validate[Seq[io.flow.github.v0.models.TagSummary]])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def getTagsBySha(
        owner: String,
        repo: String,
        sha: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Tag] = {
        _executeRequest("GET", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/tags/${play.utils.UriEncoding.encodePathSegment(sha, "UTF-8")}", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Tag", r, _.validate[io.flow.github.v0.models.Tag])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 404")
        }
      }

      override def postGitAndTags(
        owner: String,
        repo: String,
        tagForm: io.flow.github.v0.models.TagForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Tag] = {
        val payload = play.api.libs.json.Json.toJson(tagForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/tags", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.Tag", r, _.validate[io.flow.github.v0.models.Tag])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }
    }

    object Trees extends Trees {
      override def post(
        owner: String,
        repo: String,
        createTreeForm: io.flow.github.v0.models.CreateTreeForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.CreateTreeResponse] = {
        val payload = play.api.libs.json.Json.toJson(createTreeForm)

        _executeRequest("POST", s"/repos/${play.utils.UriEncoding.encodePathSegment(owner, "UTF-8")}/${play.utils.UriEncoding.encodePathSegment(repo, "UTF-8")}/git/trees", body = Some(payload), requestHeaders = requestHeaders).map {
          case r if r.status == 201 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.CreateTreeResponse", r, _.validate[io.flow.github.v0.models.CreateTreeResponse])
          case r if r.status == 404 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r if r.status == 422 => throw io.flow.github.v0.errors.UnprocessableEntityResponse(r)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 201, 404, 422")
        }
      }
    }

    object UserEmails extends UserEmails {
      override def get(
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.UserEmail]] = {
        _executeRequest("GET", s"/user/emails", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("Seq[io.flow.github.v0.models.UserEmail]", r, _.validate[Seq[io.flow.github.v0.models.UserEmail]])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401")
        }
      }
    }

    object Users extends Users {
      override def getUser(
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.User] = {
        _executeRequest("GET", s"/user", requestHeaders = requestHeaders).map {
          case r if r.status == 200 => _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.User", r, _.validate[io.flow.github.v0.models.User])
          case r if r.status == 401 => throw io.flow.github.v0.errors.UnitResponse(r.status)
          case r => throw io.flow.github.v0.errors.FailedRequest(r.status, s"Unsupported response code[${r.status}]. Expected: 200, 401")
        }
      }
    }

    def _requestHolder(path: String): play.api.libs.ws.WSRequest = {

      val holder = ws.url(baseUrl + path).addHttpHeaders(
        "User-Agent" -> Constants.UserAgent,
        "X-Apidoc-Version" -> Constants.Version,
        "X-Apidoc-Version-Major" -> Constants.VersionMajor.toString
      ).addHttpHeaders(defaultHeaders : _*)
      auth.fold(holder) {
        case Authorization.Basic(username, password) => {
          holder.withAuth(username, password.getOrElse(""), play.api.libs.ws.WSAuthScheme.BASIC)
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }
    }

    def _logRequest(method: String, req: play.api.libs.ws.WSRequest)(implicit ec: scala.concurrent.ExecutionContext): play.api.libs.ws.WSRequest = {
      val queryComponents = for {
        (name, values) <- req.queryString
        value <- values
      } yield s"$name=$value"
      val url = s"${req.url}${queryComponents.mkString("?", "&", "")}"
      auth.fold(logger.info(s"curl -X $method '$url'")) { _ =>
        logger.info(s"curl -X $method -u '[REDACTED]:' '$url'")
      }
      req
    }

    def _executeRequest(
      method: String,
      path: String,
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[play.api.libs.json.JsValue] = None
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[play.api.libs.ws.WSResponse] = {
      method.toUpperCase match {
        case "GET" => {
          _logRequest("GET", _requestHolder(path).addHttpHeaders(requestHeaders:_*).addQueryStringParameters(queryParameters:_*)).get()
        }
        case "POST" => {
          _logRequest("POST", _requestHolder(path).addHttpHeaders(_withJsonContentType(requestHeaders):_*).addQueryStringParameters(queryParameters:_*)).post(body.getOrElse(play.api.libs.json.Json.obj()))
        }
        case "PUT" => {
          _logRequest("PUT", _requestHolder(path).addHttpHeaders(_withJsonContentType(requestHeaders):_*).addQueryStringParameters(queryParameters:_*)).put(body.getOrElse(play.api.libs.json.Json.obj()))
        }
        case "PATCH" => {
          _logRequest("PATCH", _requestHolder(path).addHttpHeaders(requestHeaders:_*).addQueryStringParameters(queryParameters:_*)).patch(body.getOrElse(play.api.libs.json.Json.obj()))
        }
        case "DELETE" => {
          _logRequest("DELETE", _requestHolder(path).addHttpHeaders(requestHeaders:_*).addQueryStringParameters(queryParameters:_*)).delete()
        }
         case "HEAD" => {
          _logRequest("HEAD", _requestHolder(path).addHttpHeaders(requestHeaders:_*).addQueryStringParameters(queryParameters:_*)).head()
        }
         case "OPTIONS" => {
          _logRequest("OPTIONS", _requestHolder(path).addHttpHeaders(requestHeaders:_*).addQueryStringParameters(queryParameters:_*)).options()
        }
        case _ => {
          _logRequest(method, _requestHolder(path).addHttpHeaders(requestHeaders:_*).addQueryStringParameters(queryParameters:_*))
          sys.error("Unsupported method[%s]".format(method))
        }
      }
    }

    /**
     * Adds a Content-Type: application/json header unless the specified requestHeaders
     * already contain a Content-Type header
     */
    def _withJsonContentType(headers: Seq[(String, String)]): Seq[(String, String)] = {
      headers.find { _._1.toUpperCase == "CONTENT-TYPE" } match {
        case None => headers ++ Seq(("Content-Type" -> "application/json; charset=UTF-8"))
        case Some(_) => headers
      }
    }

  }

  object Client {

    def parseJson[T](
      className: String,
      r: play.api.libs.ws.WSResponse,
      f: (play.api.libs.json.JsValue => play.api.libs.json.JsResult[T])
    ): T = {
      f(play.api.libs.json.Json.parse(r.body)) match {
        case play.api.libs.json.JsSuccess(x, _) => x
        case play.api.libs.json.JsError(errors) => {
          throw io.flow.github.v0.errors.FailedRequest(r.status, s"Invalid json for class[" + className + "]: " + errors.mkString(" "))
        }
      }
    }

  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client {
      def baseUrl: String
      def blobs: io.flow.github.v0.Blobs
      def commits: io.flow.github.v0.Commits
      def contents: io.flow.github.v0.Contents
      def hooks: io.flow.github.v0.Hooks
      def pullRequests: io.flow.github.v0.PullRequests
      def refs: io.flow.github.v0.Refs
      def repositories: io.flow.github.v0.Repositories
      def tags: io.flow.github.v0.Tags
      def trees: io.flow.github.v0.Trees
      def userEmails: io.flow.github.v0.UserEmails
      def users: io.flow.github.v0.Users
    }

  }

  trait Blobs {
    def getBySha(
      owner: String,
      repo: String,
      sha: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Blob]

    def post(
      owner: String,
      repo: String,
      blobForm: io.flow.github.v0.models.BlobForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.BlobCreated]
  }

  trait Commits {
    def getBySha(
      owner: String,
      repo: String,
      sha: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Commit]

    def post(
      owner: String,
      repo: String,
      commitForm: io.flow.github.v0.models.CommitForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.CommitResponse]
  }

  trait Contents {
    def getReadme(
      owner: String,
      repo: String,
      ref: String = "master",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Contents]

    def getContentsByPath(
      owner: String,
      repo: String,
      path: String,
      ref: String = "master",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Contents]
  }

  trait Hooks {
    def get(
      owner: String,
      repo: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Hook]]

    def getById(
      owner: String,
      repo: String,
      id: Long,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Hook]

    def post(
      owner: String,
      repo: String,
      hookForm: io.flow.github.v0.models.HookForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Hook]

    def deleteById(
      owner: String,
      repo: String,
      id: Long,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Unit]
  }

  trait PullRequests {
    def post(
      owner: String,
      repo: String,
      pullRequestForm: io.flow.github.v0.models.PullRequestForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.PullRequest]

    def get(
      owner: String,
      repo: String,
      page: Long = 1L,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.PullRequest]]
  }

  trait Refs {
    def get(
      owner: String,
      repo: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Ref]]

    def getByRef(
      owner: String,
      repo: String,
      ref: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Ref]

    def post(
      owner: String,
      repo: String,
      refForm: io.flow.github.v0.models.RefForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Ref]

    def putByRef(
      owner: String,
      repo: String,
      ref: String,
      refUpdateForm: io.flow.github.v0.models.RefUpdateForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Ref]
  }

  trait Repositories {
    def getUserAndRepos(
      page: Long = 1L,
      visibility: io.flow.github.v0.models.Visibility = io.flow.github.v0.models.Visibility.All,
      affiliation: _root_.scala.Option[String] = None,
      `type`: _root_.scala.Option[String] = None,
      sort: String = "full_name",
      direction: String = "asc",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Repository]]

    /**
     * List public repositories for the specified user.
     */
    def getUsersAndReposByUsername(
      username: String,
      page: Long = 1L,
      `type`: String = "owner",
      sort: String = "full_name",
      direction: String = "asc",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Repository]]

    /**
     * List repositories for the specified org.
     */
    def getOrgsAndReposByOrg(
      org: String,
      page: Long = 1L,
      `type`: String = "all",
      sort: String = "full_name",
      direction: String = "asc",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.Repository]]
  }

  trait Tags {
    def getTags(
      owner: String,
      repo: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.TagSummary]]

    def getTagsBySha(
      owner: String,
      repo: String,
      sha: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Tag]

    def postGitAndTags(
      owner: String,
      repo: String,
      tagForm: io.flow.github.v0.models.TagForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.Tag]
  }

  trait Trees {
    def post(
      owner: String,
      repo: String,
      createTreeForm: io.flow.github.v0.models.CreateTreeForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.CreateTreeResponse]
  }

  trait UserEmails {
    def get(
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[Seq[io.flow.github.v0.models.UserEmail]]
  }

  trait Users {
    def getUser(
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ec: scala.concurrent.ExecutionContext): scala.concurrent.Future[io.flow.github.v0.models.User]
  }

  package errors {

    import io.flow.github.v0.models.json._

    final case class UnitResponse(status: Int) extends Exception(s"HTTP $status")

    final case class UnprocessableEntityResponse(
      response: play.api.libs.ws.WSResponse,
      message: Option[String] = None
    ) extends Exception(message.getOrElse(response.status + ": " + response.body)){
      lazy val unprocessableEntity = _root_.io.flow.github.v0.Client.parseJson("io.flow.github.v0.models.UnprocessableEntity", response, _.validate[io.flow.github.v0.models.UnprocessableEntity])
    }

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message")

  }

}